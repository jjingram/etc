# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# Source global definitions (if any).
if [ -f /etc/bashrc ]; then
  . /etc/bashrc
fi

# Prompt
PS1='\w \$ '

# Don't put duplicate lines or lines starting with space in the history.
HISTCONTROL=ignoreboth
# Append to the history file, don't overwrite it.
shopt -s histappend
# For setting history length see HISTSIZE and HISTFILESIZE in bash(1).
HISTSIZE=1000
HISTFILESIZE=2000
# History substitutions aren't immediately passed to the shell parser. Useful
# with !!, !n, !-n, !string, !?string, ^string1^string2
shopt -s histverify

# Automatically prepend `cd' when entering just a path.
shopt -s autocd

# Print a random, hopefully interesting, adage.
if [[ -f /usr/local/bin/fortune ]]; then
  fortune
  echo
fi

# Environment
export EDITOR=vim

# Modified commands
alias ls='ls -hFG'
alias mv='mv -i'
alias cp='cp -i'
alias ln='ln -i'
alias df='df -h'
alias du='du -ch'
alias ping='ping -c 5'
alias mkdir='mkdir -pv'
alias more='less'
alias grep='grep --color=auto'
alias diff='vimdiff'

# New commands
alias l='ls'
alias ll='ls -l'
alias lr='ls -R'
alias la='ll -A'
alias lz='ll -S'
alias lt='ll -t'
alias du1='du -d 1'
alias :q=' exit'

# Colored listing of directory in less.
lm() { script -q /dev/null ls -hfGlAR "$@" | less -R; }

# Colored history search in less.
h() { history | grep --color=always $1 | less -R; }

# Create an archive (*.tar.gz) from giving directory.
a() { tar cfz "${1%%/}.tar.gz" "${1%%/}/"; }

# Create a ZIP archive of a file or folder.
z() { zip -r "${1%%/}.zip" "$1"; }

# Extract common filetypes.
x() {
  if [ -f "$1" ] ; then
    case "$1" in
      *.t*)
        tar xf "$1";;
      *.bz2)
        bunzip2 "$1";;
      *.rar)
        unrar x "$1";;
      *.gz)
        gunzip "$1";;
      *.zip)
        unzip "$1";;
      *.Z)
        uncompress "$1";;
      *.7z)
        7z x "$1";;
      *)
        echo "$0: $1: Unrecognized file extension";;
    esac
  else
    echo "$0: $1: No such file"
  fi
}

# Enable bash completion in interactive shells.
# Disable ERR trap for when sourcing bashrc from an interactive shell.
trap - 0 ERR
if [ -f /usr/local/etc/bash_completion ]; then
  . /usr/local/etc/bash_completion
fi

# Intercept and display non-zero return codes.
EC() { echo -e '\n\e[1;31m'$?'\e[m'; }
trap EC ERR
