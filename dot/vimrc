set nocompatible

syntax enable

filetype on
filetype off
set rtp+=~/.vim/bundle/vundle
call vundle#rc()

Bundle 'gmarik/vundle'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-commentary'
Bundle 'tpope/vim-fugitive'
Bundle 'mileszs/ack.vim'
Bundle 'ervandew/supertab'
Bundle 'christoomey/vim-tmux-navigator'
Bundle 'justinmk/vim-sneak'
Bundle 'kwbdi.vim'
Bundle 'matchit.zip'
Bundle 'greplace.vim'

filetype plugin indent on
syntax off

set autoindent
set autoread
set backspace=2
set backup
set clipboard=unnamed
set completeopt=menu,longest
set encoding=utf-8
set expandtab
set ignorecase
set incsearch
set hidden
set history=1000
set hlsearch
set laststatus=1
set list
set listchars=tab:›\ ,trail:·,extends:#,nbsp:.
set ruler
set scrolloff=3
set shiftwidth=2
set shortmess+=filmnrxoOtT
set showcmd
set smartcase
set softtabstop=2
set tabstop=8
if has('persistent_undo')
  set undofile
  set undolevels=1000
  set undoreload=10000
endif
set wildignore=*.o
set wildmenu
set wildmode=list:longest,full
set whichwrap+=<,>,h,l,[,]

set mouse=a
if exists('$TMUX')
  set ttymouse=xterm2
endif
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=0\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
map <s-h> gT
map <s-l> gt
noremap j gj
noremap k gk
nnoremap Y y$
vnoremap < <gv
vnoremap > >gv
map zl zL
map zh zH

cmap cwd lcd %:p:h
cmap w!! w !sudo tee % >/dev/null
command! -nargs=1 Silent
      \ | execute ':silent !'.<q-args>
      \ | execute ':redraw!'
cmap mk Silent make

let mapleader=' '
map <leader>q :quit<cr>
map <leader>w :write<cr>
map <leader>e :tabedit<space>
map <leader>a :Ack<space>
map <leader>s :buffer<space>
map <leader>d <Plug>Kwbd
map <leader>z :wq<cr>
map <leader>x :bdelete<cr>
" map <leader>c
map <silent> <leader>/ :nohlsearch<cr>
map <silent> <leader>R :source ~/.vimrc<CR>
      \ :filetype detect<CR>:exe ":echo 'vimrc reloaded'"<CR>

autocmd BufRead,BufNewFile *.md set filetype=markdown
autocmd VimResized * :wincmd =
autocmd BufWritePre <buffer> call StripTrailingWhitespace()
autocmd BufWinEnter,WinEnter * let w:m2=matchadd('ColorColumn', '\%>79v.\+', -1)
autocmd FileType c,cpp setlocal shiftwidth=8 tabstop=8 noexpandtab
      \ textwidth=80 wrap cindent cinoptions=:0,l1,t0,g0 formatoptions=tcqlron
      \ listchars=tab:\ \ ,trail:·,extends:#,nbsp:.
autocmd FileType sh setlocal shiftwidth=8 tabstop=8 noexpandtab
      \ textwidth=80 wrap formatoptions=tcqlron
      \ listchars=tab:\ \ ,trail:·,extends:#,nbsp:.
autocmd FileType go :Fmt

if executable('ag')
  let g:ackprg='ag --nogroup --column'
  set grepprg=ag\ --nogroup\ --nocolor
endif

let g:SuperTabDefaultCompletionType='context'

nmap f <Plug>Sneak_s
nmap F <Plug>Sneak_S
xmap f <Plug>Sneak_s
xmap F <Plug>Sneak_S
omap f <Plug>Sneak_s
omap F <Plug>Sneak_S

function! InitializeDirectories()
  let parent = $HOME
  let prefix = 'vim/'
  let dir_list = {
        \ 'backup': 'backupdir',
        \ 'views': 'viewdir',
        \ 'swap': 'directory' }
  if has('persistent_undo')
    let dir_list['undo'] = 'undodir'
  endif
  let common_dir = parent . '/.' . prefix
  for [dirname, settingname] in items(dir_list)
    let directory = common_dir . dirname . '/'
    if exists("*mkdir")
      if !isdirectory(directory)
        call mkdir(directory)
      endif
    endif
    if !isdirectory(directory)
      echo "Warning: Unable to create backup directory: " . directory
      echo "Try: mkdir -p " . directory
    else
      let directory = substitute(directory, " ", "\\\\ ", "g")
      exec "set " . settingname . "=" . directory
    endif
  endfor
endfunction
call InitializeDirectories()

function! StripTrailingWhitespace()
  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " do the business:
  %s/\s\+$//e
  " clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction
