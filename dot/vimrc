set nocompatible

call plug#begin('~/.vim/bundle')
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-commentary'
Plug 'kana/vim-textobj-user' | Plug 'kana/vim-textobj-indent'
Plug 'altercation/vim-colors-solarized'
Plug 'Shougo/unite.vim' | Plug 'Shougo/neomru.vim'
Plug 'scrooloose/syntastic'
Plug 'christoomey/vim-tmux-navigator'
Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }
Plug 'dag/vim-fish', { 'for': 'fish' }
Plug 'hynek/vim-python-pep8-indent', { 'for': 'python' }
Plug 'fatih/vim-go', { 'for': 'go' }
Plug 'raichoo/haskell-vim', { 'for': 'haskell' }
call plug#end()

set background=light
colorscheme solarized

set textwidth=79
set clipboard=unnamed
set nojoinspaces
set hidden
set ignorecase hlsearch smartcase
set shortmess+=aoOstTI
set expandtab tabstop=4 shiftwidth=0 softtabstop=-1
set mouse=a mousehide
set noerrorbells visualbell t_vb=
set completeopt=menu,longest
set winminheight=0
set splitright
set backup
if has('persistent_undo')
    set undofile undolevels=1000 undoreload=10000
endif

let mapleader=' '
" Easier horizontal shifting.
map zl zL
map zh zH
" Kill Ex mode.
nnoremap Q <nop>
" Wrapped lines goes down/up to next row, rather than next line in file.
nnoremap j gj
nnoremap k gk
" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$
" Shift without exiting visual mode.
vnoremap < <gv
vnoremap > >gv
" Quick window switching and rolodex for horizontal splits.
nnoremap <c-h> <c-w>h
nnoremap <c-j> <c-w>j<c-w>_
nnoremap <c-k> <c-w>k<c-w>_
nnoremap <c-l> <c-w>l
" Clear search highlighting.
nnoremap <silent> <leader>/ :nohlsearch<cr>
" Toggle paste mode.
nnoremap <silent> <leader>p :set paste!<cr>
" Unite
nnoremap <silent> <leader>e :Unite -start-insert buffer neomru/file file<cr>

" Strip trailing whitespace on save.
autocmd BufWritePre <buffer> call StripTrailingWhitespace()
" Highlight characters beyond 80 columns.
autocmd BufWinEnter,WinEnter <buffer>
            \ let w:m2=matchadd('ColorColumn', '\%>80v.\+', -1)
" Automatically switch to the current file directory when a new buffer is
" opened.
autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif
" Markdown.
autocmd BufRead,BufNewFile *.md setlocal ft=markdown spell
" Go.
autocmd FileType go setlocal ts=8 noet
" Unix.
autocmd FileType c,cpp,sh,make setlocal ts=8 noet
autocmd FileType c,cpp setlocal cin fo=tcroqnl cino=:0,l1,t0,g0,(s,m1,j1,J1
" Haskell.
autocmd FileType haskell setlocal ts=2

" Syntastic.
let g:syntastic_always_populate_loc_list = 1

function! StripTrailingWhitespace()
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Let's do this!
    %s/\s\+$//e
    " Cleanup: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

" Setup directories for backup, view and swap files under ~/.vim/.
function! InitializeDirectories()
    let parent = $HOME
    let prefix = 'vim/'
    let dir_list = {
                \ 'backup': 'backupdir',
                \ 'views': 'viewdir',
                \ 'swap': 'directory',
                \ }
    if has('persistent_undo')
        let dir_list['undo'] = 'undodir'
    endif
    let common_dir = parent . '/.' . prefix
    for [dirname, settingname] in items(dir_list)
        let directory = common_dir . dirname . '/'
        if exists("*mkdir")
            if !isdirectory(directory)
                call mkdir(directory)
            endif
        endif
        if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
        else
            let directory = substitute(directory, " ", "\\\\ ", "g")
            exec "set " . settingname . "=" . directory
        endif
    endfor
endfunction
call InitializeDirectories()

