set nocompatible

call plug#begin('~/.vim/plug')
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-rsi'
Plug 'tpope/vim-dispatch'
Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-indent'
Plug 'Shougo/vimproc.vim', {'do': 'make'}
Plug 'kien/ctrlp.vim'
Plug 'altercation/vim-colors-solarized'
Plug 'scrooloose/syntastic'
Plug 'christoomey/vim-tmux-navigator'
Plug 'godlygeek/tabular'
Plug 'haya14busa/incsearch.vim'
Plug 'bruno-/vim-man'
Plug 'ervandew/supertab'
Plug 'plasticboy/vim-markdown', {'for': 'markdown'}
Plug 'neovimhaskell/haskell-vim', {'for': 'haskell'}
Plug 'bitc/vim-hdevtools', {'for': 'haskell'}
Plug 'eagletmt/neco-ghc', {'for': 'haskell'}
Plug 'klen/python-mode', {'for': 'python'}
Plug 'fatih/vim-go', {'for': 'go'}
Plug 'def-lkb/ocp-indent-vim', {'for': 'ocaml'}
call plug#end()

set background=light
colorscheme solarized

set textwidth=79
set clipboard=unnamed
set colorcolumn=80
set nocursorline
set nojoinspaces
set hidden
set ignorecase hlsearch smartcase
set shortmess+=aoOstTI
set expandtab tabstop=4 shiftwidth=0 softtabstop=-1
set mouse=a mousehide
if &term =~ '^screen'
    set ttymouse=xterm2
endif
set noerrorbells visualbell t_vb=
set completeopt=menu
set winminheight=0
set splitright
set backup
if has('persistent_undo')
    set undofile undolevels=1000 undoreload=10000
endif

let mapleader=' '
let maplocalleader=' '
nnoremap ! :!
" Easier horizontal shifting.
map zl zL
map zh zH
" NOTE: The "Q" command formerly performed this function. If you still want to
" use "Q" for formatting, use these mappings:
map Q gq
map Q gq
" Wrapped lines goes down/up to next row, rather than next line in file.
map j gj
map k gk
" Yank from the cursor to the end of the line, to be consistent with C and D.
map Y y$
" Shift without exiting visual mode.
vmap < <gv
vmap > >gv

" Strip trailing whitespace on save.
autocmd BufWritePre <buffer> call StripTrailingWhitespace()
" Highlight characters beyond 80 columns.
autocmd BufWinEnter,WinEnter <buffer>
\ if bufname("") | let w:m2=matchadd('ColorColumn', '\%>79v.\+', -1) | endif
autocmd BufRead,BufNewFile *.md setlocal ft=markdown spell
autocmd BufWinEnter quickfix setlocal linebreak

autocmd FileType go setlocal ts=8 noet
autocmd FileType c,cpp,sh,make setlocal ts=8 noet
autocmd FileType c,cpp setlocal cin fo=tcroqnl cino=:0,l1,t0,g0,(s,m1,j1,J1

function! FormatHaskell()
    if !empty(v:char)
        return 1
    else
        let l:filter = "hindent --style gibiansky"
        let l:command = v:lnum.','.(v:lnum+v:count-1).'!'.l:filter
        execute l:command
    endif
endfunction

let g:haskellmode_completion_ghc = 0
function! Haskell()
    setlocal ts=2
    setlocal omnifunc=necoghc#omnifunc
    setlocal formatexpr=FormatHaskell()
    map <buffer> <silent> <localleader>t<cr> :HdevtoolsType
    map <buffer> <silent> <localleader>c<cr> :HdevtoolsClear
endfunction
autocmd FileType haskell call Haskell()

function! OCaml()
    setlocal ts=2
    if executable('opam') && executable('ocamlmerlin') && has('python')
        let g:opamshare = substitute(system('opam config var share'),'\n$','','''')
        execute "set rtp+=" . g:opamshare . "/merlin/vim"
        execute "helptags " . g:opamshare . "/merlin/vim/doc"
        let g:syntastic_ocaml_checkers = ['merlin']
    endif
endfunction
autocmd FileType ocaml call OCaml()

set hlsearch
let g:incsearch#auto_nohlsearch = 1
map n <Plug>(incsearch-nohl-n)
map N <Plug>(incsearch-nohl-N)
map * <Plug>(incsearch-nohl-*)
map # <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_ignore_files = ['\m\.ml[ly]$']

map K <Plug>(Man)

let g:slimv_repl_split = 0
let g:slimv_leader = '\'

function! StripTrailingWhitespace()
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Let's do this!
    %s/\s\+$//e
    " Cleanup: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

" Setup directories for backup, view and swap files under ~/.vim/.
function! InitializeDirectories()
    let parent = $HOME
    let prefix = 'vim/'
    let dir_list = {
    \   'backup': 'backupdir',
    \   'views': 'viewdir',
    \   'swap': 'directory',
    \}
    if has('persistent_undo')
        let dir_list['undo'] = 'undodir'
    endif
    let common_dir = parent . '/.' . prefix
    for [dirname, settingname] in items(dir_list)
        let directory = common_dir . dirname . '/'
        if exists("*mkdir")
            if !isdirectory(directory)
                call mkdir(directory)
            endif
        endif
        if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
        else
            let directory = substitute(directory, " ", "\\\\ ", "g")
            exec "set " . settingname . "=" . directory
        endif
    endfor
endfunction
call InitializeDirectories()

function! HiGroup()
    echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
    \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
    \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"
endfunction

function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END
